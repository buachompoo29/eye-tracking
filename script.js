const mediaData = {
  "drama": {
    "Adventureland": [
      "ADVEN_3a",
      "ADVEN_12a",
      "ADVEN_15a",
      "ADVEN_18a",
      "ADVEN_24a",
      "ADVEN_9a"
    ],
    "Amazing Grace": [
      "AMAZI_14a",
      "AMAZI_20a",
      "AMAZI_2a",
      "AMAZI_2b",
      "AMAZI_8a"
    ],
    "Appaloosa": [
      "APPAL_10a",
      "APPAL_18a",
      "APPAL_2a",
      "APPAL_5a",
      "APPAL_7b"
    ],
    "Batman Forever": [
      "BATM_15a",
      "BATM_18a",
      "BATM_21a",
      "BATM_37a",
      "BATM_6a",
      "BATM_9a"
    ],
    "Blindness": [
      "BLIND_5a"
    ],
    "Bury My Heart at Wounded Knee": [
      "BURY_15a",
      "BURY_1b",
      "BURY_3a",
      "BURY_5b",
      "BURY_7a"
    ],
    "Dreamgirls": [
      "DREAMG_3a",
      "DREAMG_9a"
    ],
    "Eastern Promises": [
      "EASTE_11a",
      "EASTE_15a",
      "EASTE_19a",
      "EASTE_2a",
      "EASTE_8b"
    ],
    "Forgetting Sarah Marshall": [
      "FORGE_11a",
      "FORGE_14a",
      "FORGE_17a",
      "FORGE_8a"
    ],
    "Freedom Writers": [
      "FREED_12a",
      "FREED_14a",
      "FREED_16a",
      "FREED_2a",
      "FREED_8a"
    ],
    "He's Just Not That Into You": [
      "HESJU_12a",
      "HESJU_16b",
      "HESJU_30a",
      "HESJU_4a",
      "HESJU_8b"
    ],
    "In the Loop": [
      "LOOP_5a"
    ],
    "Julie and Julia": [
      "JULIE_10a",
      "JULIE_10b",
      "JULIE_14a",
      "JULIE_18a",
      "JULIE_22a",
      "JULIE_6a"
    ],
    "Lars and the Real Girl": [
      "LARS_12a",
      "LARS_16a",
      "LARS_20a",
      "LARS_24a",
      "LARS_4a"
    ],
    "Margot at the Wedding": [
      "MARGO_2a",
      "MARGO_4a",
      "MARGO_4b",
      "MARGO_6b",
      "MARGO_8a"
    ],
    "Miss Pettigrew Lives for a Day": [
      "MISSP_12a",
      "MISSP_15a",
      "MISSP_3a",
      "MISSP_6a",
      "MISSP_9a"
    ],
    "Nanny McPhee Returns": [
      "NANN_15a",
      "NANN_3a",
      "NANN_6a"
    ],
    "October Sky": [
      "OCTOB_11c",
      "OCTOB_13a",
      "OCTOB_3a",
      "OCTOB_5b",
      "OCTOB_7a"
    ],
    "Office Space": [
      "OFFIC_4a",
      "OFFIC_24a"
    ],
    "Pay it Forward": [
      "PAYIT_13a",
      "PAYIT_27a",
      "PAYIT_3a"
    ],
    "Recount": [
      "RECOUNT_2a",
      "RECOUNT_4a",
      "RECOUNT_4b",
      "RECOUNT_8a",
      "RECOUNT_8c"
    ],
    "Shakespeare in Love": [
      "SHAKE_16a",
      "SHAKE_20a",
      "SHAKE_24a",
      "SHAKE_28a",
      "SHAKE_8c",
      "SHAKE_11a_POR"
    ],
    "Spiderman 3": [
      "Spide_16a",
      "Spide_30a",
      "Spide_40a",
      "Spide_4a",
      "Spide_8a"
    ],
    "Stardust": [
      "STARD_16a",
      "STARD_2a",
      "STARD_4a",
      "STARD_4c",
      "STARD_7a"
    ],
    "The Hurt Locker": [
      "HURT_5a",
      "HURT_7a"
    ],
    "The Jane Austen Book Club": [
      "BOOKC_15a",
      "BOOKC_11a",
      "BOOKC_23a",
      "BOOKC_27a",
      "BOOKC_3a"
    ],
    "The Squid and the Whale": [
      "SQUID_12c",
      "SQUID_2a",
      "SQUID_4a",
      "SQUID_6a",
      "SQUID_8a"
    ],
    "The Stepfather": [
      "STEPF_16a",
      "STEPF_23a",
      "STEPF_4a",
      "STEPF_5a"
    ],
    "Big": [
      "BIG_9_10_POR"
    ],
    "Network": [
      "NETW_7a_POR"
    ],
    "Quiz Show": [
      "QUIZ_8a_POR"
    ],
    "Any Given Sunday": [
      "SUND_36a_POR"
    ]
  },
  "cartoon": {
    "Cloudy with a Chance of Meatballs": [
      "Cloud_13a",
      "Cloud_17a",
      "Cloud_17b",
      "Cloud_20a",
      "Cloud_24a",
      "Cloud_3a",
      "Cloud_6a",
      "Cloud_9a"
    ],
    "Coraline": [
      "CORAL_11a",
      "CORAL_14a",
      "CORAL_17a",
      "CORAL_5a",
      "CORAL_5b",
      "CORAL_8a"
    ],
    "Mulan": [
      "MULAN_11a",
      "MULAN_15a",
      "MULAN_19a",
      "MULAN_3a",
      "MULAN_7a"
    ],
    "Pixar Short Films Collection": [
      "GERIS_a",
      "LIFTE_a"
    ],
    "Shrek Forever After": [
      "SHREK_10a",
      "SHREK_10b",
      "SHREK_13b",
      "SHREK_15a",
      "SHREK_15b",
      "SHREK_3a",
      "SHREK_3b",
      "SHREK_5a",
      "SHREK_5b",
      "SHREK_8a"
    ],
    "the Simpsons MOVIE": [
      "SIMPS_11a",
      "SIMPS_14a",
      "SIMPS_17a",
      "SIMPS_19a",
      "SIMPS_22a",
      "SIMPS_22b",
      "SIMPS_3a",
      "SIMPS_6a",
      "SIMPS_9a"
    ]
  },
  "nature": {
    "Deep Blue": [
      "DEEPB_11a",
      "DEEPB_13a",
      "DEEPB_3a",
      "DEEPB_5a",
      "DEEPB_5b",
      "DEEPB_7a",
      "DEEPB_9a",
      "DEEPB_9b",
      "DEEPB_9c"
    ],
    "Food, Inc": [
      "FOODI_10a",
      "FOODI_2a",
      "FOODI_2b",
      "FOODI_4a",
      "FOODI_6a",
      "FOODI_8a"
    ],
    "Microcosmos": [
      "MICRO_11a",
      "MICRO_12a",
      "MICRO_2a",
      "MICRO_2b",
      "MICRO_3a",
      "MICRO_5a"
    ],
    "The March of the Penguins": [
      "MARCH_10a",
      "MARCH_12a",
      "MARCH_14a",
      "MARCH_16a",
      "MARCH_16b",
      "MARCH_18a",
      "MARCH_3a",
      "MARCH_3b",
      "MARCH_6a",
      "MARCH_6b",
      "MARCH_8a"
    ],
    "Winged Migration": [
      "WINGE_12a",
      "WINGE_15a",
      "WINGE_18a",
      "WINGE_18b",
      "WINGE_21a",
      "WINGE_3a",
      "WINGE_6a",
      "WINGE_9a"
    ],
    "Blue Planet": [
      "BLUE_10a_POR"
    ]
  }
};

const videoList = [
"ADVEN_3a_c.mov", "ADVEN_9a_c.mov", "ADVEN_12a_c.mov",
"ADVEN_15a_c.mov", "ADVEN_18a_c.mov", "ADVEN_24a_c.mov",
"AMAZI_2a_c.mov", "AMAZI_2b_c.mov", "AMAZI_8a_c.mov",
"AMAZI_14a_c.mov", "AMAZI_20a_c.mov", "APPAL_2a_c.mov",
"APPAL_5a_c.mov", "APPAL_7a_c.mov", "APPAL_7b_c.mov",
"APPAL_10a_c.mov", "APPAL_18a_c.mov", "BATM_6a_c.mov",
"BATM_9a_c.mov", "BATM_15a_c.mov", "BATM_18a_c.mov",
"BATM_21a_c.mov", "BATM_37a_c.mov", "BIG_9_10_POR_c.mov",
"BLIND_5a_c.mov", "BLUE_10a_POR_c.mov", "BOOKC_3a_c.mov",
"BOOKC_11a_c.mov", "BOOKC_15a_c.mov", "BOOKC_23a_c.mov",
"BOOKC_27a_c.mov", "BURY_1b_c.mov", "BURY_3a_c.mov",
"BURY_5b_c.mov", "BURY_7a_c.mov", "BURY_15a_c.mov",
"Cloud_3a_c.mov", "Cloud_6a_c.mov", "Cloud_9a_c.mov",
"Cloud_13a_c.mov", "Cloud_17b_c.mov", "Cloud_20a_c.mov",
"Cloud_24a_c.mov", "CORAL_5a_c.mov", "CORAL_5b_c.mov",
"CORAL_8a_c.mov", "CORAL_11a_c.mov", "CORAL_14a_c.mov",
"CORAL_17a_c.mov", "DEEPB_3a_c.mov", "DEEPB_5a_c.mov",
"DEEPB_5b_c.mov", "DEEPB_7a_c.mov", "DEEPB_9a_c.mov",
"DEEPB_9b_c.mov", "DEEPB_9c_c.mov", "DEEPB_11a_c.mov",
"DEEPB_13a_c.mov", "DREAMG_3a_c.mov", "DREAMG_9a_c.mov",
"EASTE_2a_c.mov", "EASTE_8b_c.mov", "EASTE_11a_c.mov",
"EASTE_15a_c.mov", "EASTE_19a_c.mov", "FOODI_2a_c.mov",
"FOODI_2b_c.mov", "FOODI_4a_c.mov", "FOODI_6a_c.mov",
"FOODI_8a_c.mov", "FOODI_10a_c.mov", "FORGE_8a_c.mov",
"FORGE_11a_c.mov", "FORGE_14a_c.mov", "FORGE_17a_c.mov",
"FREED_2a_c.mov", "FREED_8a_c.mov", "FREED_12a_c.mov",
"FREED_14a_c.mov", "FREED_16a_c.mov", "GERIS_a_c.mov",
"HESJU_4a_c.mov", "HESJU_8b_c.mov", "HESJU_12a_c.mov",
"HESJU_16b_c.mov", "HESJU_30a_c.mov", "HURT_5a_c.mov",
"HURT_7a_c.mov", "JULIE_6a_c.mov", "JULIE_10a_c.mov",
"JULIE_10b_c.mov", "JULIE_14a_c.mov", "JULIE_18a_c.mov",
"JULIE_22a_c.mov", "LARS_4a_c.mov", "LARS_12a_c.mov",
"LARS_16a_c.mov", "LARS_20a_c.mov", "LARS_24a_c.mov",
"LIFTE_a_c.mov", "LOOP_5a_c.mov", "MARCH_3a_c.mov",
"MARCH_3b_c.mov", "MARCH_6a_c.mov", "MARCH_6b_c.mov",
"MARCH_8a_c.mov", "MARCH_10a_c.mov", "MARCH_12a_c.mov",
"MARCH_14a_c.mov", "MARCH_16a_c.mov", "MARCH_16b_c.mov",
"MARCH_18a_c.mov", "MARGO_2a_c.mov", "MARGO_4a_c.mov",
"MARGO_4b_c.mov", "MARGO_6b_c.mov", "MARGO_8a_c.mov",
"MICRO_2a_c.mov", "MICRO_2b_c.mov", "MICRO_3a_c.mov",
"MICRO_5a_c.mov", "MICRO_11a_c.mov", "MICRO_12a_c.mov",
"MISSP_3a_c.mov", "MISSP_6a_c.mov", "MISSP_9a_c.mov",
"MISSP_12a_c.mov", "MISSP_15a_c.mov", "MULAN_3a_c.mov",
"MULAN_7a_c.mov", "MULAN_11a_c.mov", "MULAN_15a_c.mov",
"MULAN_19a_c.mov", "NANN_3a_c.mov", "NANN_6a_c.mov",
"NANN_15a_c.mov", "NETW_7a_POR_c.mov", "OCTOB_3a_c.mov",
"OCTOB_5b_c.mov", "OCTOB_7a_c.mov", "OCTOB_11c_c.mov",
"OCTOB_13a_c.mov", "OFFIC_4a_c.mov", "OFFIC_24a_c.mov",
"PAYIT_3a_c.mov", "PAYIT_13a_c.mov", "PAYIT_27a_c.mov",
"QUIZ_8a_POR_c.mov", "RECOUNT_2a_c.mov", "RECOUNT_4a_c.mov",
"RECOUNT_4b_c.mov", "RECOUNT_8a_c.mov", "RECOUNT_8c_c.mov",
"SHAKE_8c_c.mov", "SHAKE_11a_POR_c.mov", "SHAKE_16a_c.mov",
"SHAKE_20a_c.mov", "SHAKE_24a_c.mov", "SHAKE_28a_c.mov",
"SHREK_3a_c.mov", "SHREK_3b_c.mov", "SHREK_5a_c.mov",
"SHREK_5b_c.mov", "SHREK_8a_c.mov", "SHREK_10a_c.mov",
"SHREK_10b_c.mov", "SHREK_13b_c.mov", "SHREK_15a_c.mov",
"SHREK_15b_c.mov", "SIMPS_3a_c.mov", "SIMPS_6a_c.mov",
"SIMPS_9a_c.mov", "SIMPS_11a_c.mov", "SIMPS_14a_c.mov",
"SIMPS_17a_c.mov", "SIMPS_19a_c.mov", "SIMPS_22a_c.mov",
"SIMPS_22b_c.mov", "Spide_4a_c.mov", "Spide_16a_c.mov",
"Spide_30a_c.mov", "Spide_40a_c.mov", "SQUID_2a_c.mov",
"SQUID_4a_c.mov", "SQUID_6a_c.mov", "SQUID_8a_c.mov",
"SQUID_12c_c.mov", "STARD_2a_c.mov", "STARD_2b_c.mov",
"STARD_4a_c.mov", "STARD_4c_c.mov", "STARD_7a_c.mov",
"STARD_16a_c.mov", "STEPF_3a_c.mov", "STEPF_4a_c.mov",
"STEPF_5a_c.mov", "STEPF_16a_c.mov", "STEPF_23a_c.mov",
"SUND_36a_POR_c.mov", "WINGE_3a_c.mov", "WINGE_6a_c.mov",
"WINGE_9a_c.mov", "WINGE_12a_c.mov", "WINGE_15a_c.mov",
"WINGE_18a_c.mov", "WINGE_18b_c.mov", "WINGE_21a_c.mov"
]

/*Peach jigsaw */
const jigsawSnapshots = {
  a: new Set(),
  b: new Set()
};

function updateJigsawGallery(video, centerX, centerY, side, t_aligned) {
  const fixationTime = Math.round(t_aligned);

  // üõë Skip if already snapped at this fixation time
  if (jigsawSnapshots[side].has(fixationTime)) {
    console.log(`‚ö†Ô∏è Skipping duplicate snapshot at ${fixationTime}s for side ${side}`);
    return;
  }

  // ‚úÖ Mark this fixation as snapped
  jigsawSnapshots[side].add(fixationTime);

  console.log(`üß© Creating jigsaw snapshot for side: ${side}`);

  const galleryId = side === "a" ? 'jigsaw-gallery-a' : 'jigsaw-gallery-b';
  const gallery = document.getElementById(galleryId);
  if (!gallery) {
    console.warn(`‚ùå Gallery container not found: #${galleryId}`);
    return;
  }

  const size = 200;
  const x = Math.max(0, Math.min(video.videoWidth - size, centerX - size / 2));
  const y = Math.max(0, Math.min(video.videoHeight - size, centerY - size / 2));

  console.log(`üìç Cropping at x=${x.toFixed(1)}, y=${y.toFixed(1)}, from video (${video.videoWidth}x${video.videoHeight})`);

  const canvas = document.createElement("canvas");
  canvas.width = size;
  canvas.height = size;

  const ctx = canvas.getContext("2d");
  try {
    ctx.drawImage(video, x, y, size, size, 0, 0, size, size);
    const videoTime = video.currentTime.toFixed(2);

    canvas.title = `üìΩÔ∏è Video Time: ${videoTime}s`;
    canvas.dataset.timestamp = fixationTime;
    canvas.style.cursor = "pointer";

    canvas.addEventListener("click", () => {
      video.currentTime = parseFloat(canvas.dataset.timestamp);
      video.play();
    });

    gallery.appendChild(canvas);
    console.log(`‚úÖ Snapshot appended to #${galleryId}`);
  } catch (err) {
    console.error(`‚ùå Error drawing jigsaw snapshot:`, err);
  }
}


const modeState = { a: "heatmap", b: "heatmap" };

document.addEventListener("DOMContentLoaded", function () {

  const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
  const tooltipList = [...tooltipTriggerList].map(el => new bootstrap.Tooltip(el));

  document.querySelectorAll(".mode-selector").forEach(container => {
    const side = container.dataset.side;
    container.querySelectorAll(".mode-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        container.querySelectorAll(".mode-btn").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        modeState[side] = btn.dataset.mode;
      });
    });
  });
});

// Combined logic to handle dropdowns and heatmap display for both A and B panels
const groupButtons = document.getElementById("group-buttons");
const movieA = document.getElementById("movie-a");
const movieB = document.getElementById("movie-b");
const sceneA = document.getElementById("scene-a");
const sceneB = document.getElementById("scene-b");

let currentGroup = "nature";

function updateMovies(group) {
  const movies = Object.keys(mediaData[group]);
  [movieA, movieB].forEach(select => {
    select.innerHTML = "";

    // option default
    const defaultOpt = document.createElement("option");
    defaultOpt.textContent = "Select a Movie";
    defaultOpt.disabled = true;
    defaultOpt.selected = true;
    select.appendChild(defaultOpt);

    movies.forEach(movie => {
      const opt = document.createElement("option");
      opt.value = movie;
      opt.textContent = movie;
      select.appendChild(opt);
    });
  });
}

function updateScenes(movie, side) {
  const select = side === "a" ? sceneA : sceneB;
  select.innerHTML = "";

  if (!movie || !mediaData[currentGroup][movie]) {
    select.disabled = true;
    select.innerHTML = '<option value="" disabled selected hidden>Select a Scene</option>';
    return;
  }

  select.disabled = false;

  // default option
  const defaultOption = document.createElement("option");
  defaultOption.textContent = "Select a Scene";
  defaultOption.value = "";
  defaultOption.disabled = true;
  defaultOption.selected = true;
  select.appendChild(defaultOption);

  const sortedScenes = mediaData[currentGroup][movie].sort((a, b) => {
    const getSceneParts = (scene) => {
      const match = scene.match(/(\d+)([a-zA-Z]+)$/);
      return match ? [parseInt(match[1], 10), match[2]] : [0, ''];
    };
    const [numA, letterA] = getSceneParts(a);
    const [numB, letterB] = getSceneParts(b);
    return numA === numB ? letterA.localeCompare(letterB) : numA - numB;
  });

  sortedScenes.forEach(sceneId => {
    const opt = document.createElement("option");
    opt.value = sceneId;
    opt.textContent = sceneId;
    select.appendChild(opt);
  });

  select.onchange = (e) => loadScene(e.target.value, side);
}

const video = document.getElementById('video-a');
const canvas = document.getElementById('canvas-a');
const ctx = canvas.getContext('2d');

video.addEventListener('loadedmetadata', () => {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
})


;




function drawOpacityOverlay(canvas, ctx, points) {
  // console.log("‚ú® Drawing opacity overlay with", points.length, "points");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "rgba(0, 0, 0, 0.95)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  points.forEach((pt) => {

    const x = pt.x_norm;
    const y = pt.y_norm;
    const radius = 75; // larger radius for smoother transition
    // console.log("‚ú® Drawing opacity overlay at", x, y, "with radius", radius);
    // Create a radial gradient for the transparent spot
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0.0, "rgb(185, 45, 45)"); // Fully opaque at the center
    gradient.addColorStop(1.0, "rgba(200, 71, 71, 0)"); // Fully transparent at the edge

    // Set the composite operation to make the drawn area transparent
    ctx.globalCompositeOperation = "destination-out";
    ctx.fillStyle = gradient;

    // Draw the transparent spot
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, 2 * Math.PI);
    ctx.fill();
  });

  // Reset the composite operation to default for further drawing
  ctx.globalCompositeOperation = "source-over";
}


function drawRawDotsOverlay(canvas, ctx, points) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  points.forEach(pt => {
    if (pt.x_norm == null || pt.y_norm == null) return;

    const x = pt.x_norm;
    const y = pt.y_norm;
    const radius = 7; // adjust dot size as needed

    // Color based on InterestInMovie
    if (pt.interestInMovie === 1 || pt.interestInMovie === 2) {
      ctx.fillStyle = "rgba(255, 0, 0, 0.9)"; // üî¥ red group
    } else if (pt.interestInMovie >= 3 && pt.interestInMovie <= 5) {
      ctx.fillStyle = "rgba(0, 0, 255, 0.9)"; // üîµ blue group
    } else {
      return; // skip unknown or other values entirely
    }

    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
  });
}


function loadScene(sceneId, side) {
  const video = document.getElementById(`video-${side}`);
  const canvas = document.getElementById(`canvas-${side}`);
  const ctx = canvas.getContext("2d");
  const heat = window.simpleheat(canvas).radius(15, 25);
  heat.gradient({
    0.0: 'transparent',
    0.3: 'blue',
    0.5: 'lime',
    0.7: 'yellow',
    0.9: 'red'
  });

  // Clip title follow the scene
  const clipTitle = document.getElementById(`clip-title-${side}`);
  if (clipTitle) {
    clipTitle.textContent = `Scene: ${sceneId}`;
  }
  
  const fileName = videoList.find(file => file.startsWith(sceneId));
  if (!fileName) {
    alert("‚ùå Video file not found for scene: " + sceneId);
    return;
  }
  video.src = `assets/clips/${fileName}`;

  const gallery = document.getElementById(side === "a" ? 'jigsaw-gallery-a' : 'jigsaw-gallery-b');
  if (gallery) {
    gallery.innerHTML = '';
    jigsawSnapshots[side].clear(); // üßΩ Clear record for this side
    console.log(`üßº Cleared jigsaw gallery for side: ${side}`);
  }

  // üóë Reset last AOI
  video._lastAOI = null;

  video.load();

  video.addEventListener("loadedmetadata", () => {
    canvas.width = video.clientWidth;
    canvas.height = video.clientHeight;
    heat._width = canvas.width;
    heat._height = canvas.height;
    heat.resize();
  });

  //heat map from gaze data
  const baseSceneName = sceneId.toLowerCase();
  const gazeFile = `assets/data/${baseSceneName}_joined.json`;

  d3.json(gazeFile).then(data => {
    let points = data.filter(d =>
      d.x_norm !== undefined && d.y_norm !== undefined &&
      d.t_aligned !== undefined && d.participant_id !== undefined &&
      ![ -32, -32768 ].includes(d.x_norm) &&
      ![ -32, -32768 ].includes(d.y_norm) &&
      d.missing !== 1
    );

    if (points.length === 0) {
      console.warn("‚ö†Ô∏è No valid gaze points to draw.");
      return;
    }

    points.sort((a, b) => a.t_aligned - b.t_aligned);
    let buffer = [], currentPointer = 0;
    let animationId = null, lastVideoTime = 0;
    let lastRealTime = 0, lastDrawTime = 0;

    function draw(realNow = performance.now()) {
      const elapsed = realNow - lastDrawTime;
      const frameDuration = 1000 / 30;
      if (elapsed < frameDuration) {
        animationId = requestAnimationFrame(draw);
        return;
      }
      lastDrawTime = realNow;

      if (lastRealTime === 0) {
        lastRealTime = realNow;
        lastVideoTime = video.currentTime;
      }

      const elapsedReal = (realNow - lastRealTime) / 1000;
      const estimatedVideoTime = lastVideoTime + elapsedReal;

      const scaleX = canvas.width / video.videoWidth;
      const scaleY = canvas.height / video.videoHeight;
      const maxWindowSize = 2;
      const windowStart = estimatedVideoTime - maxWindowSize;

      buffer = buffer.filter(d => d.t_aligned >= windowStart);
      while (
        currentPointer < points.length &&
        points[currentPointer].t_aligned <= estimatedVideoTime
      ) {
        buffer.push(points[currentPointer]);
        currentPointer++;
      }

      const latestByParticipant = new Map();
      for (let i = buffer.length - 1; i >= 0; i--) {
        const d = buffer[i];
        if (!latestByParticipant.has(d.participant_id)) {
          latestByParticipant.set(d.participant_id, d);
        }
      }

      const heatPoints = Array.from(latestByParticipant.values()).map(d => {
        const age = estimatedVideoTime - d.t_aligned;
        const intensity = Math.min((1 - (age / maxWindowSize)) * 0.8, 0.8);
        const x = Math.round(d.x_norm * scaleX);
        const y = Math.round(d.y_norm * scaleY);
        return [x, y, intensity];
      });

      const mode = modeState[side];
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (heatPoints.length > 0) {
        const avgX = d3.mean(heatPoints, d => d[0]);
        const avgY = d3.mean(heatPoints, d => d[1]);
        const maxIntensity = d3.max(heatPoints, d => d[2]);
      
        if (!video._lastAOI) {
          video._lastAOI = { x: avgX, y: avgY };
        }
      
        const dx = avgX - video._lastAOI.x;
        const dy = avgY - video._lastAOI.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
      
        if (maxIntensity >= 0.6 && distance > 74) {
          updateJigsawGallery(video, avgX / scaleX, avgY / scaleY, side, estimatedVideoTime);
          video._lastAOI = { x: avgX, y: avgY };
        }
      }

      // THEN switch display mode
      ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (mode === "opacity") {
          // === Opacity Mode ===
          ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        
          for (const d of latestByParticipant.values()) {
            const x = Math.round(d.x_norm * scaleX);
            const y = Math.round(d.y_norm * scaleY);
            const radius = 50;
        
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.8)");
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
        
            ctx.globalCompositeOperation = "destination-out";
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
          }
        
          ctx.globalCompositeOperation = "source-over";
        
        } else if (mode === "rawdot") {
          // === Raw Dot Mode ===
          for (const d of latestByParticipant.values()) {
            const x = Math.round(d.x_norm * scaleX);
            const y = Math.round(d.y_norm * scaleY);
            const interest = +d.interestInMovie;
        
            if (interest === 1 || interest === 2) {
              ctx.fillStyle = "red";
            } else if (interest >= 3 && interest <= 5) {
              ctx.fillStyle = "blue";
            } else {
              continue; // skip unknown/invalid
            }
        
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fill();
          }
        }
        else {
          // === Heatmap Mode ===
          heat.clear();
          heat.data(heatPoints);
          heat.draw(0.3);
        }          
    
      animationId = requestAnimationFrame(draw);
    }


  

    // control button
    video.addEventListener("play", () => {
      if (!animationId) {
        lastRealTime = performance.now();
        lastVideoTime = video.currentTime;
        lastDrawTime = 0;
        animationId = requestAnimationFrame(draw);
      }
    });

    video.addEventListener("pause", () => {
      cancelAnimationFrame(animationId);
      animationId = null;
      buffer = [];
      currentPointer = 0;
      lastRealTime = 0;
    });

    video.addEventListener("ended", () => {
      cancelAnimationFrame(animationId);
      animationId = null;
      buffer = [];
      currentPointer = 0;
      lastRealTime = 0;
    });

    video.addEventListener("seeked", () => {
      buffer = [];
      currentPointer = 0;
      lastRealTime = 0;
      lastVideoTime = video.currentTime;
    });
  }).catch(err => {
    console.error("‚ùå Gaze JSON load error:", err);
  });
}

// miki added
function drawBubbleChart(scene, containerId) {
  d3.select(containerId).selectAll("*").remove();
// ‡∏ö‡∏±‡∏ß‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡∏≠‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏≠‡∏á
  const file = `assets/data/${scene.toLowerCase()}.json`;
// ‡∏ö‡∏±‡∏ß‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡∏≠‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏≠‡∏á

  d3.csv(file).then(data => {
    const row = data[0];

    const attributes = [
      "faces (0-5)",
      "human figures (0-5)",
      "nature (0-5)",
      "man-made objects (0-5)",
      "light (0-5)"
    ];

    const nodes = attributes.map(attr => ({
      radius: +row[attr] * 30,
      label: attr,
      value: +row[attr],
      environment: row.environment
    }));

    const svg = d3.select(containerId)
      .append("svg")
      .attr("width", "100%")
      .attr("height", "100%")
      .attr("viewBox", "0 0 350 350")
      .attr("preserveAspectRatio", "xMidYMid meet");

    const tooltip = d3.select("body").append("div")
      .attr("class", "tooltip")
      .style("position", "absolute")
      .style("padding", "6px 10px")
      .style("background", "rgba(0,0,0,0.75)")
      .style("color", "#fff")
      .style("font-size", "12px")
      .style("border-radius", "4px")
      .style("pointer-events", "none")
      .style("opacity", 0);

    const color = d3.scaleOrdinal()
      .domain(["indoor", "outdoor"])
      .range([colorEnvironment("indoor"), colorEnvironment("outdoor")]);

    const simulation = d3.forceSimulation(nodes)
      .force("center", d3.forceCenter(175, 175))
      .force("collide", d3.forceCollide().radius(d => d.radius + 4))
      .force("x", d3.forceX(175).strength(0.05))
      .force("y", d3.forceY(175).strength(0.05))
      .on("tick", ticked);

    const bubbles = svg.selectAll("circle")
      .data(nodes)
      .enter()
      .append("circle")
      .attr("r", d => d.radius)
      .attr("fill", d => color(d.environment))
      .attr("stroke", "white")
      .attr("stroke-width", 1.5)
      .on("mouseover", (event, d) => {
        tooltip.transition().duration(200).style("opacity", 1);
        tooltip.html(`<strong>${d.label}</strong><br/>Value: ${d.value}<br/>Env: ${d.environment}`)
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY - 20) + "px");
      })
      .on("mouseout", () => {
        tooltip.transition().duration(200).style("opacity", 0);
      });

    const labels = svg.selectAll("text")
      .data(nodes.filter(d => d.value > 0))
      .enter()
      .append("text")
      .attr("text-anchor", "middle")
      .style("fill", "white")
      .style("font-size", "10px")
      .text(d => d.label + ": " + d.value);

    function ticked() {
      bubbles
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);

      labels
        .attr("x", d => d.x)
        .attr("y", d => d.y + 4);
    }
  });
}
// ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏µ bubble ‡∏à‡∏≤‡∏Å‡πÉ‡∏ô‡∏ô‡∏µ‡πâ‡∏ô‡∏∞
function colorEnvironment(type) {
  return type === "indoor" ? "#1f77b4" : "#2ca02c"; // blue for indoor, green for outdoor
}

// miki added

// Init movie dropdowns
updateMovies(currentGroup);

movieA.addEventListener("change", () => updateScenes(movieA.value, "a"));
movieB.addEventListener("change", () => updateScenes(movieB.value, "b"));

groupButtons.addEventListener("click", e => {
  if (e.target.matches("button[data-group]")) {
    currentGroup = e.target.dataset.group;

    groupButtons.querySelectorAll("button").forEach(btn => {
      btn.classList.remove("active");
    });

    e.target.classList.add("active");

    updateMovies(currentGroup);
  }
});


const videoA = document.getElementById("video-a");
const videoB = document.getElementById("video-b");
let isSyncing = false;

// ‚ñ∂Ô∏è Play both
document.getElementById("play-both-btn").addEventListener("click", () => {
  videoA.play();
  videoB.play();
});

// ‚è∏ Pause both
document.getElementById("pause-both-btn").addEventListener("click", () => {
  videoA.pause();
  videoB.pause();
});

// üîÑ Start from beginning
document.getElementById("start-from-beginning-btn").addEventListener("click", () => {
  videoA.currentTime = 0;
  videoB.currentTime = 0;
  videoA.play();
  videoB.play();
});

// üîÅ Manual sync B = A
document.getElementById("sync-btn").addEventListener("click", () => {
  videoB.currentTime = videoA.currentTime;
});

// üîÉ Auto sync while seeking ‚Äî A ‚Üí B
videoA.addEventListener("seeking", () => {
  if (isSyncing) return;
  isSyncing = true;
  videoB.currentTime = videoA.currentTime;
});
videoA.addEventListener("seeked", () => {
  isSyncing = false;
});

// üîÉ Auto sync while seeking ‚Äî B ‚Üí A
videoB.addEventListener("seeking", () => {
  if (isSyncing) return;
  isSyncing = true;
  videoA.currentTime = videoB.currentTime;
});
videoB.addEventListener("seeked", () => {
  isSyncing = false;
});

//switch page
document.addEventListener("DOMContentLoaded", () => {
  const toggleBtn = document.getElementById("toggle-iframe-btn");
  const iframeContainer = document.getElementById("info-iframe-container");
  const mainContainer = document.getElementById("info-main-container");

  let showingIframe = true; // Start with iframe shown

  toggleBtn.addEventListener("click", () => {
    showingIframe = !showingIframe;

    iframeContainer.classList.toggle("d-none", !showingIframe);
    mainContainer.classList.toggle("d-none", showingIframe);

    toggleBtn.innerHTML = showingIframe
      ? "Dashboard Overview"
      : "Dashboard Details";
  });

  // Set initial button text
  toggleBtn.innerHTML = "üîÅ Show Dashboard View";
});

// Initialize fixationData as an empty array to avoid undefined errors
let fixationData = [];

// Fetch the fixation data from a JSON file (update the path as necessary)
d3.json('assets/data/First Fixation.json')
  .then(data => {
    fixationData = data; // Successfully loaded fixation data
    console.log('Fixation data loaded:', fixationData);
  })
  .catch(error => {
    console.error('Error loading fixation data:', error);
  });

  let chartInstanceA = null;  // Store the chart instance for Graph A
  let chartInstanceB = null;  // Store the chart instance for Graph B
  
  // Function to update Graph A and Graph B independently
  async function updateChart(movieData, canvasId, movieTitle, chartType) {
    // If chart instance exists, destroy it before creating a new one
    if (chartType === "A" && chartInstanceA) {
      chartInstanceA.destroy();
    } else if (chartType === "B" && chartInstanceB) {
      chartInstanceB.destroy();
    }
  
    // Call function to draw chart for the selected graph
    if (chartType === "A") {
      showFirstFixationScatterChart(movieData, canvasId, movieTitle, "A");
    } else if (chartType === "B") {
      showFirstFixationScatterChart(movieData, canvasId, movieTitle, "B");
    }
  }
  const genreColors = {
    "drama": "blue",
    "nature": "green",
    "cartoon": "orange"
  };
  // Function to show the first fixation scatter chart (for Graph A or B)
  async function showFirstFixationScatterChart(movieData, canvasId, movieTitle, chartType) {
    // Sort the movieData by scene ID first numerically, then alphabetically
    movieData.sort((a, b) => {
      const sceneA = a.file_name;
      const sceneB = b.file_name;
  
      const getSceneParts = (scene) => {
        const match = scene.match(/(\d+)([a-zA-Z]+)$/); // Extract number and alphabet part
        return match ? [parseInt(match[1], 10), match[2]] : [0, ''];
      };
  
      const [numA, letterA] = getSceneParts(sceneA);
      const [numB, letterB] = getSceneParts(sceneB);
  
      if (numA === numB) {
        return letterA.localeCompare(letterB); // If numbers are the same, compare alphabetically
      }
      return numA - numB; // Otherwise, compare numerically
    });
  
    // Now, after sorting, extract the labels (file_name) and fixation times in order
    const labels = movieData.map(d => d.file_name);
    const fixationTimes = movieData.map(d => d.first_fixation_time);
    const movieName = movieData[0]?.movie_name;  // Assume all movieData items belong to the same movie
    const genre = Object.keys(mediaData).find(group => mediaData[group][movieName]); // Find the genre
    const ctx = document.getElementById(canvasId).getContext("2d");
  
    const chartData = {
      datasets: [{
        label: "Avg First Fixation Time (s)",
        data: labels.map((label, index) => ({
          x: label.split('_')[1],  // Set the x-value to be the file_name (scene)
          y: fixationTimes[index], // Use fixation time for y-axis
        })),
        pointBackgroundColor: genreColors[genre], // Color the point based on genre
        pointRadius: 3,  // Adjust point size for better visibility
        borderColor: genreColors[genre], // Border color follows the genre
        borderWidth: 2,
        fill: false,  // No fill for the scatter plot
      }]
    };
  
  const yMin = 0.026; // Minimum value of First Fixation Time
  const yMax = 0.040; // Maximum value of First Fixation Time
  
  // Ensure that both charts use the same y-axis scale
  const chartOptions = {
    responsive: true,
    animation: { duration: 0 },
    plugins: {
      legend: { display: false },
      tooltip: {
        callbacks: {
          label: (ctx) => {
            const sceneName = ctx.raw.x;
            const time = ctx.raw.y.toFixed(4);
            return `Scene ${sceneName}: ${time} sec`;
          }
        }
      },
      title: {
        display: true,
        text: movieTitle,
        font: { size: 10, weight: "bold" }
      }
    },
    onClick: function (evt, activeElements) {
      if (activeElements.length > 0) {
        const index = activeElements[0].index;
        const sceneLabel = labels[index]; // e.g., "MULAN_7a"
        console.log(`üé¨ Loading scene: ${sceneLabel}`);
        const normalizedScene = videoList.find(file =>
          file.toUpperCase().startsWith(sceneLabel.toUpperCase())
        );
        
        if (normalizedScene) {
          const sceneId = normalizedScene.split("_c")[0]; // remove _c.mov suffix if needed
          loadScene(sceneId, chartType.toLowerCase()); // "a" or "b"
        } else {
          alert("‚ùå Scene not found in videoList: " + sceneLabel);
        }
      }
    },
    onHover: function(evt, activeElements) {
      evt.native.target.style.cursor = activeElements.length ? 'pointer' : 'default';
    }
    ,
    scales: {
      y: {
        beginAtZero: false,
        min: yMin, // Use the same min value across all charts
        max: yMax, // Use the same max value across all charts
        stepSize: 0.002,
        ticks: {
          min: yMin,
          max: yMax,
          callback: function(value) {
            return value.toFixed(3);
          }
        },
        title: { display: true, text: "Time (seconds)" }
      },
      x: {
        type: 'category',
        labels: labels.map(label => label.split('_')[1]),    // Use the file names as x-axis labels
        title: { display: true, text: "Scene" }
      }
    }
  };
  
    if (chartType === "A") {
      // If it's Graph A, create a new chart instance for it
      chartInstanceA = new Chart(ctx, {
        type: "scatter", // Change type to scatter plot
        data: chartData,
        options: chartOptions
      });
    } else if (chartType === "B") {
      // If it's Graph B, create a new chart instance for it
      chartInstanceB = new Chart(ctx, {
        type: "scatter", // Change type to scatter plot
        data: chartData,
        options: chartOptions
      });
    }
  }
  
// Event listeners for when movie is changed for Graph A or Graph B
movieA.addEventListener("change", () => {
  updateScenes(movieA.value, "a");
  // Filter data for selected movie from the fixationData
  const movieData = fixationData.filter(d => d.movie_name === movieA.value);
  updateChart(movieData, "first-fixation-chart-a", `${movieA.value} - First Fixation Time by Scene`, "A");
});

movieB.addEventListener("change", () => {
  updateScenes(movieB.value, "b");
  const movieData = fixationData.filter(d => d.movie_name === movieB.value);
  updateChart(movieData, "first-fixation-chart-b", `${movieB.value} - First Fixation Time by Scene`, "B");
});